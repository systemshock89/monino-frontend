{"version":3,"file":"../animations.min.js","sources":["animations.min.js"],"sourcesContent":["\"use strict\";\r\n\r\nanimateElements({\r\n    container: 'features-circles-anim',\r\n    element: 'features-circles__item',\r\n    classAnimEnd: 'bounceInRight'\r\n});\r\n\r\nanimateElements({\r\n    container: 'text-block_two-columns-anim',\r\n    element: 'text-container:nth-child(1)',\r\n    classAnimEnd: 'bounceInLeft'\r\n});\r\n\r\nanimateElements({\r\n    container: 'text-block_two-columns-anim',\r\n    element: 'text-container:nth-child(2)',\r\n    classAnimEnd: 'bounceInRight'\r\n});\r\n\r\nanimateElements({\r\n    container: 'features-anim',\r\n    element: 'features__item',\r\n    classAnimEnd: 'fadeIn'\r\n});\r\n\r\nfunction animateElements({container, element, classAnimStart, classAnimEnd, threshold = 0.25, once = false}){\r\n    /**\r\n     * container - класс контейнера, на который ставится наблюдатель\r\n     * element - класс анимируемого эл-та (добавить ему visibility: hidden)\r\n     * classAnimStart - класс начальной точки анимации (при keyframes он не нужен)\r\n     * classAnimEnd - класс конечной точки анимации\r\n     * threshold - допустимый процент пересечения контейнера, когда начнется анимация\r\n     * (на мобильниках начинаем анимацию сразу же: threshold = 0)\r\n     * once - проиграть анимацию только 1 раз\r\n     */\r\n    if(window.outerWidth <= 768){\r\n        threshold = 0;\r\n    }\r\n\r\n    const observer = new IntersectionObserver(entries => {\r\n        entries.forEach(entry => {\r\n            const elements = entry.target.querySelectorAll('.' + container + ' .' + element);\r\n            elements.forEach(el => {\r\n                if(classAnimStart){\r\n                    el.classList.add(classAnimStart);\r\n                }\r\n\r\n                setTimeout(() =>{\r\n                    if(once){\r\n                        if(entry.isIntersecting){\r\n                            el.classList.add(classAnimEnd);\r\n                        }\r\n                    } else {\r\n                        el.classList.toggle(classAnimEnd, entry.isIntersecting);\r\n                    }\r\n                }, 100);\r\n            });\r\n        });\r\n    }, {\r\n        threshold: threshold\r\n    });\r\n\r\n    const observeContainers = document.querySelectorAll('.' + container);\r\n    observeContainers.forEach(el => observer.observe(el));\r\n}"],"names":["animateElements","container","element","classAnimStart","classAnimEnd","threshold","once","window","outerWidth","observer","IntersectionObserver","entries","forEach","entry","target","querySelectorAll","el","classList","add","setTimeout","isIntersecting","toggle","document","observe"],"mappings":"AAAA,aA0BA,SAASA,gBAAgB,CAACC,UAAAA,EAAWC,QAAAA,EAASC,eAAAA,EAAgBC,aAAAA,EAAcC,UAAAA,EAAY,IAAMC,KAAAA,EAAO,CAAA,CAAK,GAUnGC,OAAOC,YAAc,MACpBH,EAAY,GAGhB,MAAMI,EAAW,IAAIC,qBAAqBC,IACtCA,EAAQC,QAAQC,IACKA,EAAMC,OAAOC,iBAAiB,IAAMd,EAAY,KAAOC,CAAO,EACtEU,QAAQI,IACVb,GACCa,EAAGC,UAAUC,IAAIf,CAAc,EAGnCgB,WAAW,KACJb,EACIO,EAAMO,gBACLJ,EAAGC,UAAUC,IAAId,CAAY,EAGjCY,EAAGC,UAAUI,OAAOjB,EAAcS,EAAMO,cAAc,CAE9D,EAAG,GAAG,CACV,CAAC,CACL,CAAC,CACL,EAAG,CACCf,UAAWA,CACf,CAAC,EAEyBiB,SAASP,iBAAiB,IAAMd,CAAS,EACjDW,QAAQI,GAAMP,EAASc,QAAQP,CAAE,CAAC,CACxD,CA/DAhB,gBAAgB,CACZC,UAAW,wBACXC,QAAS,yBACTE,aAAc,eAClB,CAAC,EAEDJ,gBAAgB,CACZC,UAAW,8BACXC,QAAS,8BACTE,aAAc,cAClB,CAAC,EAEDJ,gBAAgB,CACZC,UAAW,8BACXC,QAAS,8BACTE,aAAc,eAClB,CAAC,EAEDJ,gBAAgB,CACZC,UAAW,gBACXC,QAAS,iBACTE,aAAc,QAClB,CAAC"}